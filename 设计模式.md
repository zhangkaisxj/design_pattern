### 23种设计模式 ###
* 创建型模式(5)<br>
工厂方法模式，建造者模式，抽象工厂模式，单例模式，原型模式<br>
* 结构型模式(7)<br>
适配器模式,桥梁模式，组合模式，装饰模式，门面模式，享元模式，代理模式
* 行为类模式(11)<br>
责任链模式，命令模式，解释器模式，迭代器模式，中介者模式，备忘录模式，观察者模式，状态模式，策略模式，模板方法模式，访问者模式，<br>


### 设计模式六大原则 ###
1. 单一职责原则 <br>
一个类只做一件事。<br>
2. 依赖倒置原则 <br>
依赖于抽象而不要依赖于具体，针对接口编程而不要针对于实现编程 <br>
3. 迪米特法则 <br>
一个软件实体应当尽可能少地与其他实体发生相互作用<br>
4. 开放封闭原则<br>
对修改关闭，对扩展开放<br>
5. 里氏替换原则<br>
任何一个使用父类的地方都可以用子类来进行替换<br>
6. 接口隔离原则<br>
使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。<br>
### 创建型模式 ###
1. 简单工厂模式<br>
简单工厂模式不属于23中设计模式之一，将创建对象的工作转移到了工厂类。
<img src="./pic/0.jpg"><br>
2. 工厂方法模式<br>
将类的实例化（具体产品的创建）延迟到工厂类的子类（具体工厂）中完成，即由子类来决定应该实例化（创建）哪一个类。<br>
<img src = "./pic/1.jpg"><br>
3. 抽象工厂模式 <br>
抽象工厂模式是所有形态的工厂模式中最为抽象和最具一般性的一种形态。抽象工厂模式是指当有多个抽象角色时，使用的一种工厂模式。抽象工厂模式可以向客户端提供一个接口，使客户端在不必指定产品的具体的情况下，创建多个产品族中的产品对象。
<img src = "./pic/2.jpg"><br>
4. 观察者模式<br>
定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
<img src="./pic/5.jpg">
5. 装饰器模式<br>
装饰器模式允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。<br>这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。<br>
<img src="./pic/6.jpg">
6. 单例模式<br>
保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br>
实现方式:<br>
* 不考虑是否现场安全，直接使用
* 在方法外加上synchronized，使用起来方便，但是效率降低
* 类加载时直接初始化，现场安全，但是浪费内存
* 将类内的对象声明为volatile,并且在创建的时候加以判断
<img src="./pic/4.jpg" width=50%>
7. 命令模式<br>
命令模式是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。<br>
<img src="./pic/7.jpg">
8. 策略模式<br>
一个类的行为或其算法可以在运行时更改<br>
定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。<br>
在类内定义这些算法的实体，而不是用方法<br>
<img src="./pic/3.jpg">
